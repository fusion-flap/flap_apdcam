#ifndef __APDCAM10G_BYTES_H__
#define __APDCAM10G_BYTES_H__

#include <vector>
#include <cstdint>
#include <algorithm>
#include <iostream>
#include <cstddef>
#include <sstream>
#include "error.h"
#include "safeness.h"


namespace apdcam10g
{
    // Ensure clear endianness (i.e. all numeric types having the same endianness... on some rare platforms
    // integer and floating-point types have different endianness, which is not handled by this code)
    // For mixed-endian systems std::endian::native does not equal any of big or little
    static_assert(std::endian::native == std::endian::big || std::endian::native == std::endian::little, "Mixed-endian system, the code can not be compiled on this machine, sorry");

    template<bool is_signed, int N> class shortest_int 
    {
        static_assert(false,"Signed integers must be represented by the same number of bytes as their native size");
    };

    // For signed integers, specializations are only provided for the native fixed-width types
    // stored in the same number of bytes as their native size. If tried to be used with a different
    // number of bytes, the unspecified default will fail due to static_assert
    template<> class shortest_int<true,sizeof(int8_t)>  { public: typedef int8_t type; };
    template<> class shortest_int<true,sizeof(int16_t)> { public: typedef int16_t type; };
    template<> class shortest_int<true,sizeof(int32_t)> { public: typedef int32_t type; };
    template<> class shortest_int<true,sizeof(int64_t)> { public: typedef int64_t type; };

    // For unsigned integer types, all sizes up to 8 bytes are specialized, so we will not fall back to the unspecialized
    // (failing) default class above. 
    template<> class shortest_int<false,1> { public: typedef uint_fast8_t type; };
    template<> class shortest_int<false,2> { public: typedef uint_fast16_t type; };
    template<> class shortest_int<false,3> { public: typedef uint_fast32_t type; };
    template<> class shortest_int<false,4> { public: typedef uint_fast32_t type; };
    template<> class shortest_int<false,5> { public: typedef uint_fast64_t type; };
    template<> class shortest_int<false,6> { public: typedef uint_fast64_t type; };
    template<> class shortest_int<false,7> { public: typedef uint_fast64_t type; };
    template<> class shortest_int<false,8> { public: typedef uint_fast64_t type; };


    check should be replaced by safeness::safe or unsafe

    template<bool must_convert, typename T, int N, std::endian E, bool check=true> class byte_converter {};

    // The converter which actually does not make a conversion (first template argument is 'false')
    // just maps the memory representation of the given type T to the byte array
    template<typename T, int N, std::endian E, bool check> class byte_converter<false,T,N,E,check>
    {
        // Make sure that the size of the native type T is matching the  number of bytes
        static_assert(sizeof(T)==N);
        // Also make sure that the required endianness is the system's native one
        static_assert(std::endian::native == E);
    private:
        std::byte *address_=0;
        T *value_=0;
    public:
        byte_converter(std::byte *a=0) : address_(a), value_((T*)a) {}
        void address(std::byte *a) 
            { 
                address_ = a; 
                value_ = (T*)a;
            }
        byte_converter<false,T,N,E,check> &operator=(const T &t) { *value_ = t; return *this; }
        operator T() const { return *value_; }
    };
    
    template<typename T, int N, std::endian E, bool check> class byte_converter<true,T,N,E,check>
    {
    private:
        mutable union
        {
            T value;
            std::byte mem[sizeof(T)];
        } storage_;
        std::byte *address_ = 0;
    public:
        byte_converter(std::byte *a =0) : address_(a) {}
        void address(std::byte *a)
            {
                address_ = a;
            }
        byte_converter<true,T,N,E,check> &operator=(const T &t)
            {
                storage_.value = t;

                if(check && N !=sizeof(T)) // optimized out at compile time if not needed
                {
                    // Loop over the truncated bytes (the most significant ones which will be discarded
                    // because we are down-converting to a smaller number of bytes from the native type T
                    for(unsigned int i=(std::endian::native==std::endian::little ? N : 0); 
                        i<(std::endian::native==std::endian::little ? sizeof(T) : sizeof(T)-N); 
                        ++i)
                    {
                        if(storage_.mem[i] != 0) 
                        { 
                            std::string msg;
                            std::ostringstream msgstream(msg);
                            msgstream<<"The value '"<<t<<"' does not fit into "<<N<<" bytes";
                            APDCAM_ERROR(msg);
                        }
                    }
                }
                

                // Now copy the least significant bytes. Remember that the native type used to represent this value, T, may be
                // longer than the number of bytes in the buffer. So we do need to take care to only copy N bytes, the
                // least significant ones
                // The conditions of these ifs are evaluable at compile time and will be optimized out
                if(std::endian::native == std::endian::little)
                {
                    if(E == std::endian::native) std::copy        (storage_.mem, storage_.mem+N,address_); // if no endianness reversion is needed
                    else                         std::reverse_copy(storage_.mem, storage_.mem+N,address_); // if endianness reversion is needed
                }
                else
                {
                    if(E == std::endian::native) std::copy        (storage_.mem+sizeof(T)-N, storage_.mem+sizeof(T),address_);
                    else                         std::reverse_copy(storage_.mem+sizeof(T)-N, storage_.mem+sizeof(T),address_);
                }
                return *this;
            }
        operator T() const
            {
                // Make sure that unused bytes in the native type representation are zero
                std::fill(storage_.mem,storage_.mem+sizeof(T),0);
                if(std::endian::native == std::endian::little)
                {
                    if(E == std::endian::native) std::copy        (address_, address_+N, storage_.mem);
                    else                         std::reverse_copy(address_, address_+N, storage_.mem);
                }
                else
                {
                    if(E == std::endian::native) std::copy        (address_, address_+N, storage_.mem+sizeof(T)-N);
                    else                         std::reverse_copy(address_, address_+N, storage_.mem+sizeof(T)-N);
                }
                return storage_.value;
            }
    };



    /*
    class bytearray : std::vector<unsigned char>
    {
    public:
        template <typename T>
            bytearray(const T &t, endian::type byteorder, int n=0);
        
        template <typename T>
            static bytearray from(const T &t, int n, endian::type byteorder);
    };

    bytearray operator+(const bytearray &b1, const bytearray &b2)
    {
        bytearray result = b1;
        result.insert(result.end(),b2.begin(),b2.end());
        return result;
    }

    template <>
        bytearray::bytearray(const unsigned int &value, endian::type byteorder, int n) : std::vector<unsigned char>((n==0 ? sizeof(unsigned int) : n))
    {
        const int N = size();
        for(int i=0; i<N; ++i)
        {
            int target_index = i;
            if(byteorder == endian::big) target_index = N-i;
            if(i<sizeof(unsigned int)) (*this)[target_index] = (unsigned char)((value>>(8*i)) & 0xff);
            else (*this)[target_index] = 0;
        }
    }
    */
}

#endif
